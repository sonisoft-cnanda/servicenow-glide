import { GlideAggregate, GlideRecord, GlideSysAttachment, gs, XMLDocument2 } from "../types";
import { VulnerabilityUtils } from "./VulnerabilityUtils";

export class VulnerabilityIntegrationBase {
    public integrationGr: GlideRecord | null = null; // set by VulnerabilityIntegrationController
    public integrationProcessGr: GlideRecord | null = null; // set by Vulnerability Controller
    public sizeLimitExceeded: boolean = false;
    private _nextRunParams: any = null;
    private _hasMoreData: boolean = false;
    public requiresMultipleCalls: boolean = false;
    public shouldMakeCall: boolean = false;

    constructor() {
        // Initialization code here
    }

    public retrieveData(): { contents: string, contentType: string, extension: string } {
        return {
            contents: "",
            contentType: "",
            extension: ""
        };
    }

    public hasMoreData(optBoolean?: boolean): boolean {
        if (optBoolean != null) {
            this._hasMoreData = optBoolean;
        }
        return this._hasMoreData;
    }

    public finalizeRun(): boolean {
        return true;
    }

    public deleteAttachments(tableName: string, recordSysId: string): void {
        const attachment = new GlideRecord("sys_attachment");
        attachment.addQuery("table_name", tableName);
        attachment.addQuery("table_sys_id", recordSysId);
        attachment.query();
        const attachUtil = new GlideSysAttachment();
        while (attachment.next()) {
            gs.info("Deleting the attachment: " + (attachment as any).file_name);
            attachUtil.deleteAttachment(attachment.getUniqueValue());
        }
    }

    public getNextRunParameters(): any {
        return this._nextRunParams;
    }

    public setNextRunParameters(paramObject: any): void {
        this._nextRunParams = paramObject;
    }

    private _getProcessParameters(): any {
        if (gs.nil(this.integrationProcessGr) || gs.nil((this.integrationProcessGr as any).parameters)) {
            return null;
        }

        try {
            const encodedParams = this.integrationProcessGr.getValue("parameters");
            
            return JSON.parse(encodedParams);
        } catch (e) {
            gs.warn("Encountered error parsing process parameters, treating as null parameters");
            gs.warn(e);
            return null;
        }
    }

    private _getRunParameters(): any {
        if (gs.nil(this.integrationProcessGr) ||
            gs.nil((this.integrationProcessGr as any).integration_run) ||
            gs.nil((this.integrationProcessGr as any).integration_run.parameters)) {
            return null;
        }

        try {
            const encodedParams = (this.integrationProcessGr as any).integration_run.parameters + "";
            //const json = new global.JSON();
            return JSON.parse(encodedParams);
        } catch (e) {
            gs.warn("Encountered error parsing run parameters, treating as null parameters");
            gs.warn(e);
            return null;
        }
    }

    public validateRetrievedData(result: any): boolean {
        return true;
    }

    public validateAttachmentSize(report: any, process: any): void {
        this.sizeLimitExceeded = false;
        const maxSize = gs.getProperty('sn_sec_cmn.max_integration_payload_size');
        const attachment = new GlideRecord('sys_attachment');
        if (report && report.contents && attachment.get(report.contents.toString()) && parseInt((attachment as any).size_bytes) > parseInt(maxSize)) {
            this.sizeLimitExceeded = true;
            throw gs.getMessage("Error: The payload attachment size is {0} bytes. It cannot exceed {1} bytes. Modify the integration instance parameters to ensure that the payload attachment size is within the specified limit.", [(attachment as any).size_bytes, maxSize]);
        }
    }

    public skipRetryByScheduleJob(integrationProcessGr: GlideRecord): boolean {
        return false;
    }

    public shouldRetry(process: any): boolean {
        return false;
    }

    public getNextRetry(retry: string): number {
        return Math.pow(2, (parseInt(retry) + 1));
    }

    public getMaxRetry(): number {
        return 5;
    }

    public onDataProcessed(process: any, result: any): void {
        if ((this.integrationGr as any).report_processor_strategy + "" == "DATA_SOURCE") {
            this._updateIntegrationProcess(process, 'waitComplete');
        } else {
            this._updateIntegrationProcess(process, 'complete');
        }
    }

    public countDownloadedAttachmets(process: any): void {
        this.countProcesses(process);
    }

    public countProcesses(process: any): void {
        let comp = 0;
        let wait = 0;
        const ga = new GlideAggregate("sn_vul_integration_process");
        ga.addQuery("integration_run", process.integration_run + "");
        ga.addQuery("state", "IN", "complete,waitComplete");
        ga.groupBy("state");
        ga.addAggregate("COUNT");
        ga.query();
        while (ga.next()) {
            if (ga.getValue("state") == "complete") {
                comp = parseInt(ga.getAggregate("COUNT"));
            } else if (ga.getValue("state") == "waitComplete") {
                wait = parseInt(ga.getAggregate("COUNT"));
            }
        }
        const run = new GlideRecord("sn_vul_integration_run");
        run.addQuery("sys_id", process.integration_run + "");
        run.setLimit(1);
        run.query();
        if (run.next()) {
            run.setValue("downloaded_attach", comp + wait);
            run.setValue("processed_attach", comp);
            run.setValue("percent_complete", (comp / (comp + wait)) * 100);
            run.update();
        }
    }

    public onImportQueueProcessed(process: any): void {
        let entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "NOT IN", "COMPLETE,ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            return; // We still have items in progress
        }
        entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        entryGr.addQuery("integration_process", process.getUniqueValue());
        entryGr.addQuery("status", "ERROR");
        entryGr.setLimit(1);
        entryGr.query();
        if (entryGr.next()) {
            this._updateIntegrationProcess(process, "complete", "Some import queue entries are in error");
            return;
        }
        this._updateIntegrationProcess(process, "complete");
        this.countProcessedAttachment(process);
    }

    public countProcessedAttachment(process: any): void {
        this.countProcesses(process);
    }

    private _updateIntegrationProcess(procGr: GlideRecord, state: string, notes?: string): void {
        procGr.setValue('state', state);
        if (notes) {
            procGr.setValue('notes', notes);
        }
        procGr.update();
    }

    public onProcessComplete(process: any): void {
        let isComplete = false;
        let isError = false;

        const integrationRun = process.integration_run;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun, isComplete, isError, totals);
    }

    public onRunWaitForComplete(integrationRun: any): void {
        let isComplete = false;
        let isError = false;
        if (!integrationRun) {
            return;
        }
        const totals = this._calculateCount(integrationRun);
        if (integrationRun.state + "" == "waitComplete") {
            isComplete = this._checkInteRunComplete(integrationRun);
        }
        if (isComplete) {
            isError = this._checkInteRunError(integrationRun);
        }
        this._updateIntegrationRun(integrationRun.getUniqueValue(), isComplete, isError, totals);
    }

    private _checkInteRunComplete(integrationGr: GlideRecord): boolean {
        const entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        // entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        // entryGr.addQuery('status', 'NOT IN', 'COMPLETE,ERROR');
        // entryGr.setLimit(1);
        // entryGr.query();
        return !(entryGr.hasNext());
    }

    private _checkInteRunError(integrationGr: GlideRecord): boolean {
        const entryGr = new GlideRecord("sn_vul_ds_import_q_entry");
        // entryGr.addQuery("integration_process.integration_run", integrationGr.sys_id + "");
        // entryGr.addQuery('status', 'ERROR');
        // entryGr.setLimit(1);
        // entryGr.query();
        return entryGr.hasNext();
    }

    private _updateIntegrationRun(runGrId: string, isComplete: boolean, isError: boolean, totals: any): void {
        const runGr = new GlideRecord("sn_vul_integration_run");
        if (!runGr.get(runGrId)) {
            return;
        }
        runGr.setValue("import_vi", totals.import_vi);
        runGr.setValue("vi_created", totals.vi_created);
        runGr.setValue("vi_updated", totals.vi_updated);
        runGr.setValue("vi_new_findings", totals.vi_updated_new_findings);
        runGr.setValue("vi_unchanged", totals.vi_unchanged);
        runGr.setValue("vi_duplicates", totals.vi_duplicates);
        runGr.setValue("vi_ignored", totals.vi_ignored);
        runGr.setValue("det_created", totals.det_created);
        runGr.setValue("det_updated", totals.det_updated);
        runGr.setValue("det_unchanged", totals.det_unchanged);
        runGr.setValue("det_ignored", totals.det_ignored);
        runGr.setValue("det_excluded", totals.det_excluded);
        runGr.setValue("import_ci", totals.import_ci);
        runGr.setValue("ci_created", totals.ci_created);
        runGr.setValue("ci_identified", totals.ci_identified);
        runGr.setValue("ci_ignored", totals.ci_ignored);
        runGr.update();

        if (isComplete) {
            const util = new VulnerabilityUtils();
            const state = 'complete';
            const substate = isError ? 'failed' : 'success';
            const notes = isError ?
                gs.getMessage("At least one import queue entry is in error.  No more data to process at this time.") :
                gs.getMessage("Successfully completed integration run.  No more data to process at this time.");

            //util.updateIntegrationRun(runGr, state, substate, notes);
        }
    }

    private _calculateCount(inteRun: GlideRecord): any {
        const totals = {
            import_vi: 0,
            vi_created: 0,
            vi_updated: 0,
            vi_unchanged: 0,
            vi_duplicates: 0,
            vi_ignored: 0,
            det_created: 0,
            det_updated: 0,
            det_unchanged: 0,
            det_excluded: 0,
            det_ignored: 0,
            import_ci: 0,
            ci_created: 0,
            ci_identified: 0,
            ci_ignored: 0,
            vi_updated_new_findings: 0
        };
        const processGr = new GlideAggregate("sn_vul_integration_process");
        processGr.addQuery("integration_run", (inteRun as any).sys_id + "");
        processGr.addAggregate('SUM', 'import_vi');
        processGr.addAggregate('SUM', 'vi_created');
        processGr.addAggregate('SUM', 'vi_updated');
        processGr.addAggregate('SUM', 'vi_new_findings');
        processGr.addAggregate('SUM', 'vi_unchanged');
        processGr.addAggregate('SUM', 'vi_ignored');
        processGr.addAggregate('SUM', 'vi_duplicates');
        processGr.addAggregate('SUM', 'det_created');
        processGr.addAggregate('SUM', 'det_updated');
        processGr.addAggregate('SUM', 'det_unchanged');
        processGr.addAggregate('SUM', 'det_ignored');
        processGr.addAggregate('SUM', 'det_excluded');
        processGr.addAggregate('SUM', 'import_ci');
        processGr.addAggregate('SUM', 'ci_created');
        processGr.addAggregate('SUM', 'ci_identified');
        processGr.addAggregate('SUM', 'ci_ignored');
        processGr.setGroup(false);
        processGr.query();
        if (processGr.next()) {
            // totals.import_vi = processGr.getAggregate('SUM', 'import_vi');
            // totals.vi_created = processGr.getAggregate('SUM', 'vi_created');
            // totals.vi_updated = processGr.getAggregate('SUM', 'vi_updated');
            // totals.vi_updated_new_findings = processGr.getAggregate('SUM', 'vi_new_findings');
            // totals.vi_unchanged = processGr.getAggregate('SUM', 'vi_unchanged');
            // totals.vi_ignored = processGr.getAggregate('SUM', 'vi_ignored');
            // totals.vi_duplicates = processGr.getAggregate('SUM', 'vi_duplicates');
            // totals.det_created = processGr.getAggregate('SUM', 'det_created');
            // totals.det_updated = processGr.getAggregate('SUM', 'det_updated');
            // totals.det_unchanged = processGr.getAggregate('SUM', 'det_unchanged');
            // totals.det_ignored = processGr.getAggregate('SUM', 'det_ignored');
            // totals.det_excluded = processGr.getAggregate('SUM', 'det_excluded');
            // totals.import_ci = processGr.getAggregate('SUM', 'import_ci');
            // totals.ci_created = processGr.getAggregate('SUM', 'ci_created');
            // totals.ci_identified = processGr.getAggregate('SUM', 'ci_identified');
            // totals.ci_ignored = processGr.getAggregate('SUM', 'ci_ignored');
        }
        return totals;
    }

    public isProcessStartedByFramework(process: any): boolean {
        return true;
    }

    public validateXML(body: string, errorNodeName?: string): void {
        if (!body) return;

        const doc = new XMLDocument2();
        doc.parseXML(body);

        let err = null;

        try {
            const root = doc.getFirstNode('/' + doc.getDocumentElement().getNodeName());

            if (errorNodeName && root.getNodeName() == errorNodeName) {
                err = root.getTextContent();
            } else {
                doc.getNextNode(root);
            }
        } catch (e) {
            throw 'XML document syntax invalid';
        }

        if (err) {
            throw 'Integration responded with: ' + err;
        }
    }

    private _shouldAutoTruncate(process: any): boolean {
        const gr = new GlideAggregate("sn_vul_integration_process");
        gr.addEncodedQuery('parametersLIKE"truncation"^stateINcomplete,waitComplete^integration_run=' + process.integration_run + "");
        gr.addAggregate("COUNT");
        gr.query();
        if (gr.next()) {
            return parseInt(gr.getAggregate("COUNT")) < 5;
        }
        return true;
    }

    private _getTruncationLimit(actualTruncation: number, currentSize: number, threshold: number): number {
        let val:number = actualTruncation * (threshold / currentSize);
        const truncation:number = parseInt(val + '');
        if (gs.nil(truncation) || truncation <= 0) {
            return actualTruncation;
        }
        return truncation;
    }

    public getStatusCodeMessage(statusCode: number, placeholder: string): string {
        return (new VulnerabilityUtils()).getStatusCodeMessage(statusCode, placeholder);
    }
}